---
title: "lists"
lesson: 4
quizzes:
  - question: "how do you add an item to the end of a list?"
    options:
      - "list.add(item)"
      - "list.append(item)"
      - "list.insert(item)"
      - "list.push(item)"
    correct: 1
  - question: "what does list[0] return?"
    options:
      - "the last item"
      - "the first item"
      - "the second item"
      - "error"
    correct: 1
  - question: "how do you get the length of a list?"
    options:
      - "list.length()"
      - "list.size()"
      - "len(list)"
      - "list.count()"
    correct: 2
---

# lists

**real world analogy**: lists are like a playlist on your phone. you can add songs, remove them, rearrange the order, and play them one by one. each song has a position number, and you can jump to any song instantly by knowing its position.

## understanding lists

lists are python's way of organizing multiple pieces of related information. imagine having a shopping list, a to-do list, or a guest list - lists in python work exactly the same way, keeping everything organized and accessible.

```python
# list of grocery items
shopping_list = ["milk", "bread", "eggs", "cheese"]
# list of numbers
lucky_numbers = [7, 13, 21, 42]
# list with different data types
mixed_data = ["alice", 25, True, 3.14]
```

each list is contained within square brackets, with items separated by commas. lists can hold any type of data - text, numbers, booleans, or even other lists. they're incredibly flexible containers.

## accessing items by position

lists use index numbers to identify each item's position, starting from 0 (not 1). it's like apartment numbers in a building - each item has a specific address you can use to find it instantly.

```python
# create a list of colors
colors = ["red", "green", "blue", "yellow"]

# access items by position (index)
first_color = colors[0]      # "red" (first item)
second_color = colors[1]     # "green" (second item)
last_color = colors[-1]      # "yellow" (last item)
second_last = colors[-2]     # "blue" (second to last)
```

positive numbers count from the beginning (0, 1, 2...), while negative numbers count from the end (-1, -2, -3...). this gives you flexible ways to access items from either direction.

## adding new items to your list

lists are dynamic - you can grow them by adding new items. python provides several methods for adding items in different positions.

```python
fruits = ["apple", "banana"]

fruits.append("orange")
fruits.append("grape")

fruits.insert(1, "mango")
fruits.insert(0, "strawberry")
```

append() adds items to the end of the list, like adding a new song to the end of your playlist. insert() lets you add items at any specific position, pushing existing items to make room.

## removing items from your list

sometimes you need to remove items from your list. python gives you multiple ways to delete items, depending on whether you know the item's value or its position.

```python
animals = ["cat", "dog", "bird", "fish", "cat"]

animals.remove("cat")
removed_animal = animals.pop(2)
last_animal = animals.pop()
```

remove() deletes the first occurrence of a specific value. pop() removes and returns an item at a specific position (or the last item if no position is given). this lets you both remove and capture the removed item.

## essential list operations

lists come with built-in methods that make common operations simple and efficient. these methods handle the complex work behind the scenes.

```python
scores = [85, 92, 78, 92, 88, 95]

total_scores = len(scores)
highest_score = max(scores)
lowest_score = min(scores)
average_score = sum(scores) / len(scores)

scores.sort()
count_of_92 = scores.count(92)
position_of_88 = scores.index(88)
```

len() tells you how many items are in the list. max() and min() find the highest and lowest values. sum() adds all numbers together. sort() arranges items in order, and count() tells you how many times a value appears.

## iterating through lists

loops and lists work together perfectly. you can process every item in a list automatically, like going through each song in a playlist.

```python
favorite_movies = ["inception", "avatar", "interstellar"]

for movie in favorite_movies:
    print(f"i love watching {movie}")

for i, movie in enumerate(favorite_movies):
    print(f"{i+1}. {movie}")
```

the first loop processes each movie directly. the second loop uses enumerate() to get both the position and the value, perfect for creating numbered lists.

## list slicing - getting portions

sometimes you need just part of a list, not the whole thing. slicing lets you extract specific sections, like getting the first 5 songs from a 100-song playlist.

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

first_three = numbers[:3]
middle_section = numbers[3:7]
last_three = numbers[-3:]
every_second = numbers[::2]
```

slicing uses the format [start:stop:step]. you can omit any part - [:3] means "from beginning to position 3", [3:] means "from position 3 to end", and [::2] means "every second item".

## real-world applications

lists are everywhere in programming - storing user accounts, managing inventory, tracking high scores, organizing files, handling shopping carts, and processing data. they're fundamental to most applications.

## practice challenges

1. create a gradebook that stores student names and calculates class average
2. build a simple inventory system that tracks product quantities
3. make a playlist manager that can add, remove, and shuffle songs
4. create a voting system that counts and ranks preferences

## example from class

here's a dynamic list program that demonstrates various list operations:

```python
# list of 5 items and display each item individually.
# once u enter anything random it will display at the end of the list
arr = []

for i in range(5):
    inp = input(f"enter stuff for the list {i+1}: ")
    arr.append(inp)

arr.insert(len(arr)//2, 2)  # the // operator is used to perform floor division, the floor division is the division that results into whole number adjusted to the left in the number line
# so this inserts 2 at the middle of the list by dividing the length of the list by 2.
arr.pop(0)
# swap the second and last elements with each other
arr[1], arr[-1] = arr[-1], arr[1]

arr.append(3)  # adds 3 at the end of the list.

for item in arr:
    print(item)
```

**what this code demonstrates:**
- **empty list creation**: starts with `arr = []` to create an empty list
- **append() method**: adds user input to the end of the list
- **for loop with range()**: collects exactly 5 items from user
- **insert() method**: adds item at specific position using `len(arr)//2` for middle
- **floor division (//)**: calculates middle position by dividing length by 2
- **pop() method**: removes first item at index 0
- **list swapping**: exchanges second and last elements using tuple assignment
- **negative indexing**: uses `arr[-1]` to access last element
- **iteration**: prints each item using for loop

this example shows how lists can be dynamically modified with insertions, deletions, and swaps, demonstrating the flexible nature of Python lists.

## key concepts mastered

• lists store multiple related items in order
• indexing starts at 0, negative indices count from the end
• append() adds to the end, insert() adds at specific positions
• remove() deletes by value, pop() removes by position
• len(), max(), min(), sum() provide essential statistics
• slicing extracts portions of lists with [start:stop:step]
• lists are mutable • you can modify them after creation
• loops and lists work together for powerful data processing
