---
title: "Variable Types & Type Conversion"
lesson: 12
quizzes:
  - question: "Which function converts a string to an integer?"
    options:
      - "str()"
      - "int()"
      - "float()"
      - "convert()"
    correct: 1
  - question: "What is the result of: type(3.14)?"
    options:
      - "<class 'int'>"
      - "<class 'float'>"
      - "<class 'str'>"
      - "<class 'number'>"
    correct: 1
  - question: "Which type is mutable?"
    options:
      - "int"
      - "str"
      - "tuple"
      - "list"
    correct: 3
  - question: "What does bool('') return?"
    options:
      - "True"
      - "False"
      - "None"
      - "Error"
    correct: 1
---

# Variable Types & Type Conversion

Python is dynamically typed, meaning variables can hold different types of data. Understanding types and how to convert between them is fundamental to Python programming.

## Basic Data Types

```python
age = 25
price = 19.99
name = "Alice"
is_active = True
result = None

print(type(age))
print(type(price))
print(type(name))
print(type(is_active))
```

## Checking Types

```python
x = 42
print(type(x))
print(isinstance(x, int))
print(isinstance(x, (int, float)))
```

## Type Conversion (Casting)

```python
text = "123"
number = int(text)
print(number)

text = "3.14"
float_num = float(text)
print(float_num)

num = 42
text = str(num)
print(text)

print(bool(1))
print(bool(0))
print(bool(""))
```

## Numeric Types

```python
x = 10
y = 3
print(x + y)
print(x / y)
print(x // y)
print(x % y)
print(x ** y)
```

## Collection Types

```python
numbers = [1, 2, 3]
coordinates = (10, 20)
person = {"name": "Alice", "age": 25}
unique = {1, 2, 3}

print(type(numbers))
print(type(coordinates))
print(type(person))
print(type(unique))
```

## Converting Collections

```python
text = "hello"
chars = list(text)
print(chars)

words = ["Hello", "World"]
text = " ".join(words)
print(text)

numbers = [1, 2, 3]
tuple_numbers = tuple(numbers)
print(tuple_numbers)

numbers = [1, 2, 2, 3]
unique = set(numbers)
print(unique)
```

### Dictionary Keys/Values to List

```python
person = {"name": "Alice", "age": 25}
keys = list(person.keys())
values = list(person.values())
items = list(person.items())
print(keys)
print(values)
print(items)
```

## Mutable vs Immutable

### Immutable Types

```python
x = 10
print(id(x))
x = 20
print(id(x))

text = "hello"
print(id(text))
text = "world"
print(id(text))
```

### Mutable Types

```python
numbers = [1, 2, 3]
print(id(numbers))
numbers.append(4)
print(id(numbers))
```

## Type Annotations

### Basic Annotations

```python
name: str = "Alice"
age: int = 25
price: float = 19.99
is_active: bool = True
```

### Function Annotations

```python
def greet(name: str) -> str:
    return f"Hello, {name}!"

def add(a: int, b: int) -> int:
    return a + b
```

### Collection Annotations

```python
from typing import List, Dict, Tuple, Set

numbers: List[int] = [1, 2, 3]
person: Dict[str, str] = {"name": "Alice"}
coordinates: Tuple[int, int] = (10, 20)
unique: Set[int] = {1, 2, 3}
```

### Optional Types

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None
```

## Truthy and Falsy Values

### Falsy Values

```python
print(bool(False))
print(bool(None))
print(bool(0))
print(bool(0.0))
print(bool(""))
print(bool([]))
print(bool({}))
print(bool(()))
print(bool(set()))
```

### Truthy Values

```python
print(bool(True))
print(bool(1))
print(bool(-1))
print(bool("hello"))
print(bool([1]))
print(bool({"key": "value"}))
```

## Type Checking in Practice

### Safe Type Conversion

```python
def safe_int(value, default=0):
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

print(safe_int("123"))
print(safe_int("abc"))
print(safe_int(None))
```

### Type Validation

```python
def validate_age(age):
    if not isinstance(age, int):
        raise TypeError("Age must be an integer")
    if age < 0:
        raise ValueError("Age cannot be negative")
    return True

try:
    validate_age(25)
    validate_age("25")
except TypeError as e:
    print(e)
```

## Advanced Type Conversions

### Binary, Octal, Hex

```python
number = 42
print(bin(number))
print(oct(number))
print(hex(number))

binary = "0b101010"
print(int(binary, 2))

hex_num = "0x2A"
print(int(hex_num, 16))
```

### ASCII and Unicode

```python
print(ord("A"))
print(chr(65))

print(ord("Î±"))
print(chr(945))
```

### Bytes Conversion

```python
text = "hello"
encoded = text.encode("utf-8")
print(encoded)
print(type(encoded))

decoded = encoded.decode("utf-8")
print(decoded)
print(type(decoded))
```

## Numeric Type Hierarchy

```python
x = 10
print(isinstance(x, int))
print(isinstance(x, float))

y = 3.14
print(isinstance(y, float))
print(isinstance(y, int))

import numbers
print(isinstance(x, numbers.Number))
print(isinstance(y, numbers.Number))
```

## Practical Examples

### Parse User Input

```python
def get_number(prompt):
    while True:
        user_input = input(prompt)
        try:
            return float(user_input)
        except ValueError:
            print("Invalid number, try again")
```

### Convert Data Types

```python
data = {
    "age": "25",
    "price": "19.99",
    "active": "true",
    "count": "0"
}

converted = {
    "age": int(data["age"]),
    "price": float(data["price"]),
    "active": data["active"].lower() == "true",
    "count": int(data["count"])
}

print(converted)
```

### Type-Safe Function

```python
def calculate_total(prices: list) -> float:
    if not isinstance(prices, list):
        raise TypeError("prices must be a list")
    
    total = 0.0
    for price in prices:
        if not isinstance(price, (int, float)):
            raise TypeError(f"Invalid price type: {type(price)}")
        total += price
    
    return total

print(calculate_total([10.5, 20.0, 15.75]))
```

### Dynamic Type Handling

```python
def process_value(value):
    if isinstance(value, str):
        return value.upper()
    elif isinstance(value, (int, float)):
        return value * 2
    elif isinstance(value, list):
        return len(value)
    else:
        return None

print(process_value("hello"))
print(process_value(10))
print(process_value([1, 2, 3]))
```

## Common Mistakes

**Invalid conversion:**
```python
number = int("abc")
```

**Float to int loses precision:**
```python
x = 3.99
y = int(x)
print(y)
```

**Comparing different types:**
```python
if "10" == 10:
    print("Equal")
```

## Practice Challenges

Try these exercises:

1. Create a function that converts any value to boolean
2. Write a function that safely converts strings to numbers
3. Implement a type checker that validates function arguments
4. Create a converter between temperature units
5. Build a function that normalizes mixed-type data

## Key Points

- Python has dynamic typing
- Main types: `int`, `float`, `str`, `bool`, `None`
- Use `type()` to check type, `isinstance()` for validation
- Convert types with `int()`, `float()`, `str()`, `bool()`
- Immutable: `int`, `float`, `str`, `tuple`
- Mutable: `list`, `dict`, `set`
- Empty collections and zero are falsy
- Type annotations improve code clarity
- Always handle conversion errors with try-except
- Use `isinstance()` for type checking in functions

Understanding types and conversions is crucial for writing robust Python code that handles data correctly and avoids runtime errors.
