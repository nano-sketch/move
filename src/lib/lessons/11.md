---
title: "operators & modulus"
lesson: 11
quizzes:
  - question: "what does the % operator do?"
    options:
      - "percentage calculation"
      - "returns the remainder after division"
      - "multiplies by 100"
      - "divides by 100"
    correct: 1
  - question: "what does 17 % 5 equal?"
    options:
      - "3"
      - "2"
      - "4"
      - "1"
    correct: 1
  - question: "how can you check if a number is even?"
    options:
      - "number % 2 == 0"
      - "number / 2 == 0"
      - "number * 2 == 0"
      - "number + 2 == 0"
    correct: 0
---

# operators & modulus

**real world analogy**: operators are like tools in a toolbox. just as you use different tools for different jobs (hammer for nails, screwdriver for screws), python uses different operators for different mathematical operations. the modulus operator (%) is like a special measuring tool that tells you what's left over after dividing things into equal groups.

## understanding mathematical operators

python provides powerful mathematical operators that let you perform calculations, compare values, and manipulate data with precision.

```python
# basic arithmetic operators
a = 15
b = 4

# addition
sum_result = a + b          # 19
# subtraction  
diff_result = a - b         # 11
# multiplication
product = a * b             # 60
# division (float result)
division = a / b            # 3.75
# floor division (integer result)
floor_div = a // b          # 3
# exponentiation (power)
power = a ** b              # 50625
# modulus (remainder)
remainder = a % b           # 3

print(f"{a} + {b} = {sum_result}")
print(f"{a} - {b} = {diff_result}")
print(f"{a} * {b} = {product}")
print(f"{a} / {b} = {division}")
print(f"{a} // {b} = {floor_div}")
print(f"{a} ** {b} = {power}")
print(f"{a} % {b} = {remainder}")
```

each operator serves a specific purpose. regular division (/) always returns a decimal, while floor division (//) gives you just the whole number part.

## mastering the modulus operator

the modulus operator (%) is incredibly useful • it returns the remainder after division. think of it as "what's left over" when you divide numbers.

```python
# understanding modulus with examples
print("modulus examples:")
print(f"10 % 3 = {10 % 3}")  # 1 (10 ÷ 3 = 3 remainder 1)
print(f"15 % 4 = {15 % 4}")  # 3 (15 ÷ 4 = 3 remainder 3)
print(f"20 % 5 = {20 % 5}")  # 0 (20 ÷ 5 = 4 remainder 0)
print(f"7 % 2 = {7 % 2}")    # 1 (7 ÷ 2 = 3 remainder 1)
print(f"8 % 2 = {8 % 2}")    # 0 (8 ÷ 2 = 4 remainder 0)

# practical modulus applications
def check_even_odd(number):
    if number % 2 == 0:
        return "even"
    else:
        return "odd"

# test with different numbers
numbers = [5, 12, 7, 20, 13]
for num in numbers:
    result = check_even_odd(num)
    print(f"{num} is {result}")
```

when the remainder is 0, it means the first number divides evenly into the second. this is perfect for checking if numbers are even, odd, or divisible by other numbers.

## finding prime numbers with modulus

prime numbers are numbers greater than 1 that can only be divided by 1 and themselves. modulus helps us check this efficiently.

```python
def is_prime(number):
    # numbers less than 2 are not prime
    if number < 2:
        return False
    
    # check if number is divisible by any number from 2 to its square root
    for i in range(2, int(number ** 0.5) + 1):
        if number % i == 0:  # if remainder is 0, it's divisible
            return False     # not prime
    
    return True  # if no divisors found, it's prime

def find_primes_up_to(limit):
    primes = []
    for num in range(2, limit + 1):
        if is_prime(num):
            primes.append(num)
    return primes

# find all prime numbers up to 30
prime_numbers = find_primes_up_to(30)
print(f"prime numbers up to 30: {prime_numbers}")

# test specific numbers
test_numbers = [17, 25, 29, 33, 37]
for num in test_numbers:
    if is_prime(num):
        print(f"{num} is prime")
    else:
        print(f"{num} is not prime")
```

this algorithm uses modulus to check if a number has any divisors. if we find even one divisor (remainder = 0), the number isn't prime.

## practical modulus applications

modulus has many real world uses beyond prime numbers. it's essential for cycling through values, creating patterns, and solving everyday programming problems.

```python
# cycling through days of the week
def get_day_of_week(day_number):
    days = ["monday", "tuesday", "wednesday", "thursday", 
            "friday", "saturday", "sunday"]
    # use modulus to cycle through days
    return days[day_number % 7]

# test day cycling
for i in range(15):
    day = get_day_of_week(i)
    print(f"day {i}: {day}")

# checking divisibility rules
def divisibility_checker(number):
    results = []
    
    if number % 2 == 0:
        results.append("divisible by 2")
    if number % 3 == 0:
        results.append("divisible by 3")
    if number % 5 == 0:
        results.append("divisible by 5")
    if number % 10 == 0:
        results.append("divisible by 10")
    
    return results if results else ["not divisible by 2, 3, 5, or 10"]

# test divisibility
test_nums = [12, 15, 20, 23, 30]
for num in test_nums:
    rules = divisibility_checker(num)
    print(f"{num}: {', '.join(rules)}")
```

modulus helps create repeating patterns and check mathematical properties efficiently.

## comparison and logical operators

beyond arithmetic, python provides operators for comparing values and combining conditions.

```python
# comparison operators
x = 10
y = 15

print(f"{x} == {y}: {x == y}")  # equal to
print(f"{x} != {y}: {x != y}")  # not equal to
print(f"{x} < {y}: {x < y}")    # less than
print(f"{x} > {y}: {x > y}")    # greater than
print(f"{x} <= {y}: {x <= y}")  # less than or equal
print(f"{x} >= {y}: {x >= y}")  # greater than or equal

# logical operators
a = True
b = False

print(f"{a} and {b}: {a and b}")  # both must be true
print(f"{a} or {b}: {a or b}")    # at least one must be true
print(f"not {a}: {not a}")        # opposite of the value

# combining conditions
age = 25
has_license = True

can_drive = age >= 18 and has_license
print(f"can drive: {can_drive}")

# complex conditions with modulus
number = 24
is_even_and_divisible_by_3 = (number % 2 == 0) and (number % 3 == 0)
print(f"{number} is even and divisible by 3: {is_even_and_divisible_by_3}")
```

combining modulus with logical operators creates powerful condition checking capabilities.

## real world applications

operators power everything from financial calculations (interest, taxes) to game mechanics (scoring, collision detection) to data analysis (statistical calculations, pattern recognition). modulus specifically is used in cryptography, hash functions, and creating repeating patterns.

## practice challenges

1. create a function that finds all factors of a number using modulus
2. build a simple calculator that handles all arithmetic operations
3. make a pattern generator that uses modulus to create repeating sequences
4. design a divisibility rule checker for numbers 2 through 12

## key concepts mastered

• arithmetic operators (+, -, *, /, //, **, %) perform mathematical calculations
• modulus (%) returns the remainder after division
• modulus is perfect for checking even/odd, divisibility, and creating cycles
• prime number detection uses modulus to check for divisors
• comparison operators (==, !=, <, >, <=, >=) compare values
• logical operators (and, or, not) combine conditions
• operators are essential tools for mathematical computation and logical decision making
