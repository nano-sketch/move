---
title: "Error Handling"
lesson: 9
quizzes:
  - question: "Which keyword is used to catch exceptions?"
    options:
      - "catch"
      - "except"
      - "error"
      - "handle"
    correct: 1
  - question: "What does 'finally' block do?"
    options:
      - "Runs only if error occurs"
      - "Runs only if no error"
      - "Always runs regardless of errors"
      - "Stops the program"
    correct: 2
  - question: "How do you raise a custom exception?"
    options:
      - "throw Exception()"
      - "raise Exception()"
      - "error Exception()"
      - "create Exception()"
    correct: 1
  - question: "Which exception is raised when dividing by zero?"
    options:
      - "ValueError"
      - "TypeError"
      - "ZeroDivisionError"
      - "ArithmeticError"
    correct: 2
---

# Error Handling

Error handling allows your programs to gracefully handle unexpected situations instead of crashing. It's essential for building robust, production-ready applications.

## What are Exceptions?

Exceptions are errors that occur during program execution. Without proper handling, they cause your program to crash.

```python
print(10 / 0)
```

## Try-Except Blocks

```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")

try:
    number = int("abc")
except ValueError:
    print("Invalid number format")
except TypeError:
    print("Wrong type")
```

## Accessing Exception Details

```python
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Error: {e}")
    print(f"Type: {type(e).__name__}")
```

## Else Clause

Runs if no exception occurs:

```python
try:
    result = 10 / 2
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print(f"Result: {result}")
```

## Finally Clause

```python
file = None
try:
    file = open("data.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("File not found")
finally:
    if file:
        file.close()
    print("Cleanup complete")
```

## Common Exception Types

```python
try:
    number = int("abc")
except ValueError:
    print("Cannot convert to integer")

try:
    result = "5" + 5
except TypeError:
    print("Cannot add string and integer")

try:
    person = {"name": "Alice"}
    age = person["age"]
except KeyError:
    print("Key not found")

try:
    numbers = [1, 2, 3]
    value = numbers[10]
except IndexError:
    print("Index out of range")
```

## Raising Exceptions

```python
def divide(a, b):
    if b == 0:
        raise ValueError("Divisor cannot be zero")
    return a / b

try:
    result = divide(10, 0)
except ValueError as e:
    print(e)
```

## Custom Exceptions

```python
class InvalidAgeError(Exception):
    pass

def set_age(age):
    if age < 0:
        raise InvalidAgeError("Age cannot be negative")
    return age

try:
    set_age(-5)
except InvalidAgeError as e:
    print(e)
```

## Nested Try-Except

```python
try:
    try:
        result = 10 / 0
    except ZeroDivisionError:
        print("Inner exception caught")
        raise ValueError("Converted error")
except ValueError as e:
    print(f"Outer exception: {e}")
```

## Context Managers

### Using 'with' Statement

```python
try:
    with open("data.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("File not found")
```

## Assertion Errors

### Using Assertions

```python
def calculate_average(numbers):
    assert len(numbers) > 0, "List cannot be empty"
    return sum(numbers) / len(numbers)

try:
    avg = calculate_average([])
except AssertionError as e:
    print(e)
```

## Best Practices

### Be Specific

```python
try:
    number = int(input("Enter number: "))
except ValueError:
    print("Invalid number")
```

### Don't Catch Everything

```python
try:
    risky_operation()
except Exception:
    pass
```

### Log Errors

```python
import logging

try:
    result = 10 / 0
except ZeroDivisionError as e:
    logging.error(f"Error occurred: {e}")
```

## Real-World Examples

### Safe File Reading

```python
def read_file(filename):
    try:
        with open(filename, "r") as file:
            return file.read()
    except FileNotFoundError:
        print(f"File {filename} not found")
        return None
    except PermissionError:
        print(f"No permission to read {filename}")
        return None
```

### Safe User Input

```python
def get_integer(prompt):
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Please enter a valid integer")
```

### Safe Dictionary Access

```python
def get_user_age(users, username):
    try:
        return users[username]["age"]
    except KeyError:
        return None
    except TypeError:
        return None
```

### API Request Handling

```python
def fetch_data(url):
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.ConnectionError:
        print("Connection failed")
    except requests.Timeout:
        print("Request timed out")
    except requests.HTTPError as e:
        print(f"HTTP error: {e}")
    except ValueError:
        print("Invalid JSON response")
```

## Debugging with Exceptions

### Print Stack Trace

```python
import traceback

try:
    result = 10 / 0
except ZeroDivisionError:
    traceback.print_exc()
```

### Get Stack Trace as String

```python
import traceback

try:
    result = 10 / 0
except ZeroDivisionError:
    error_msg = traceback.format_exc()
    print(error_msg)
```

## Exception Hierarchy

```python
try:
    result = 10 / 0
except ArithmeticError:
    print("Math error")
except Exception:
    print("General error")
except BaseException:
    print("Base error")
```

## Common Patterns

### Retry Logic

```python
def retry_operation(func, max_attempts=3):
    for attempt in range(max_attempts):
        try:
            return func()
        except Exception as e:
            if attempt == max_attempts - 1:
                raise
            print(f"Attempt {attempt + 1} failed, retrying...")
```

### Fallback Values

```python
def safe_divide(a, b, default=0):
    try:
        return a / b
    except ZeroDivisionError:
        return default
```

### Validation

```python
def validate_email(email):
    if "@" not in email:
        raise ValueError("Email must contain @")
    if "." not in email:
        raise ValueError("Email must contain domain")
    return True
```

## Common Mistakes

**Catching too broadly:**
```python
try:
    code()
except:
    pass
```

**Not handling specific cases:**
```python
try:
    value = data[key]
except:
    value = None
```

**Ignoring exceptions:**
```python
try:
    important_operation()
except Exception:
    pass
```

## Practice Challenges

Try these exercises:

1. Write a function that safely converts string to integer
2. Create a function that reads a file with error handling
3. Implement a calculator with division error handling
4. Write a custom exception for invalid email
5. Create a retry mechanism for network requests

## Key Points

- Use `try-except` to handle exceptions
- Catch specific exceptions, not all exceptions
- Use `finally` for cleanup code
- `else` runs when no exception occurs
- Raise exceptions with `raise` keyword
- Create custom exceptions by inheriting from `Exception`
- Always close resources in `finally` or use `with`
- Log errors for debugging
- Don't silently ignore exceptions
- Use assertions for debugging, not error handling

Proper error handling makes your code more reliable, maintainable, and user-friendly. It's a sign of professional programming.
