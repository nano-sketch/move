---
title: "file handling"
lesson: 9
quizzes:
  - question: "which mode opens a file for reading?"
    options:
      - "w"
      - "r"
      - "a"
      - "x"
    correct: 1
  - question: "what does the 'with' statement do when working with files?"
    options:
      - "opens the file faster"
      - "automatically closes the file"
      - "creates the file if it doesn't exist"
      - "makes the file read-only"
    correct: 1
  - question: "which mode will overwrite an existing file?"
    options:
      - "r"
      - "a"
      - "w"
      - "x"
    correct: 2
---

# file handling

**real world analogy**: file handling is like managing documents in a filing cabinet. you can open a folder to read its contents, write new information, add notes to existing documents, or create entirely new files. python gives you the same control over digital files.

## understanding file operations

files are how programs store and retrieve data permanently. unlike variables that disappear when your program ends, files persist on your computer's storage, making them perfect for saving user data, settings, and results.

```python
with open("greeting.txt", "w") as file:
    file.write("hello, world!")
    file.write("\nwelcome to python file handling!")

with open("greeting.txt", "r") as file:
    content = file.read()
    print(content)
```

this code creates a new file called "greeting.txt", writes two lines to it, then reads the entire file back and displays it. the "with" statement automatically handles opening and closing the file safely.

## file modes and their purposes

different file modes give you different capabilities, like having different keys for different types of access to a room.

```python
modes_demo = {
    "r": "read only - file must exist",
    "w": "write only - creates new or overwrites existing",
    "a": "append only - adds to end of existing file",
    "r+": "read and write - file must exist",
    "w+": "read and write - creates new or overwrites",
    "a+": "read and append - creates if doesn't exist"
}

filename = "demo.txt"

with open(filename, "w") as file:
    file.write("original content\n")

with open(filename, "a") as file:
    file.write("appended content\n")

with open(filename, "r") as file:
    print("file contents:")
    print(file.read())
```

write mode ("w") completely replaces file contents, while append mode ("a") adds to the end. read mode ("r") only allows viewing the file without changes.

## reading files in different ways

python offers multiple ways to read files, each suited for different situations and file sizes.

```python
def demonstrate_reading_methods(filename):
    print("method 1: read entire file at once")
    with open(filename, "r") as file:
        content = file.read()
        print(f"content: {repr(content)}")
    
    print("\nmethod 2: read line by line")
    with open(filename, "r") as file:
        for line_number, line in enumerate(file, 1):
            print(f"line {line_number}: {line.strip()}")
    
    print("\nmethod 3: read all lines into a list")
    with open(filename, "r") as file:
        lines = file.readlines()
        print(f"total lines: {len(lines)}")
        for i, line in enumerate(lines):
            print(f"line {i}: {repr(line)}")

with open("sample.txt", "w") as file:
    file.write("first line\nsecond line\nthird line\n")

demonstrate_reading_methods("sample.txt")
```

read() loads the entire file into memory, readline() reads one line at a time (memory efficient for large files), and readlines() creates a list of all lines. choose based on your file size and processing needs.

## writing and organizing data

writing to files lets you save program results, user data, and create reports that persist beyond program execution.

```python
def create_student_report(students):
    with open("student_report.txt", "w") as file:
        file.write("student grade report\n")
        file.write("=" * 30 + "\n\n")
        
        total_score = 0
        for student in students:
            name = student["name"]
            score = student["score"]
            grade = get_letter_grade(score)
            
            file.write(f"{name:<15} {score:>3} ({grade})\n")
            total_score += score
        
        average = total_score / len(students)
        file.write("\n" + "-" * 30 + "\n")
        file.write(f"class average: {average:.1f}\n")

def get_letter_grade(score):
    if score >= 90: return "A"
    elif score >= 80: return "B"
    elif score >= 70: return "C"
    elif score >= 60: return "D"
    else: return "F"

students = [
    {"name": "alice", "score": 92},
    {"name": "bob", "score": 87},
    {"name": "charlie", "score": 95},
    {"name": "diana", "score": 78}
]

create_student_report(students)
print("report created successfully!")
```

this example creates a formatted report file with student grades and statistics. the formatting makes the file readable both by programs and humans.

## handling file errors safely

file operations can fail for many reasons - missing files, permission issues, or disk problems. proper error handling prevents crashes and provides helpful feedback.

```python
def safe_file_operations(filename):
    try:
        with open(filename, "r") as file:
            content = file.read()
            print(f"successfully read {len(content)} characters")
            return content
    
    except FileNotFoundError:
        print(f"error: {filename} does not exist")
        return None
    
    except PermissionError:
        print(f"error: no permission to read {filename}")
        return None
    
    except Exception as e:
        print(f"unexpected error: {e}")
        return None

def safe_write_file(filename, content):
    try:
        with open(filename, "w") as file:
            file.write(content)
        print(f"successfully wrote to {filename}")
        return True
    
    except PermissionError:
        print(f"error: no permission to write {filename}")
        return False
    
    except Exception as e:
        print(f"error writing file: {e}")
        return False

content = safe_file_operations("data.txt")
if content:
    processed = content.upper()
    safe_write_file("output.txt", processed)
```

this pattern handles the most common file errors gracefully, allowing your program to continue running even when file operations fail.

## creating a simple logging system

logging systems track program activity, errors, and user actions - essential for debugging and monitoring applications.

```python
import datetime

def log_message(message, level="INFO"):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[{timestamp}] {level}: {message}\n"
    
    with open("application.log", "a") as file:
        file.write(log_entry)
    
    print(f"logged: {message}")

def simulate_application():
    log_message("application started")
    log_message("user logged in", "INFO")
    log_message("processing data", "INFO")
    log_message("invalid input detected", "WARNING")
    log_message("database connection failed", "ERROR")
    log_message("application shutting down")

def read_log_file():
    try:
        with open("application.log", "r") as file:
            print("application log contents:")
            print("-" * 40)
            print(file.read())
    except FileNotFoundError:
        print("no log file found")

simulate_application()
read_log_file()
```

this logging system timestamps every entry and categorizes messages by importance level. logs are invaluable for understanding what happened when problems occur.

## real-world applications

file handling powers data storage, configuration management, report generation, backup systems, data import/export, and logging in virtually every professional application.

## practice challenges

1. create a personal diary program that saves entries with timestamps
2. build a contact manager that stores and retrieves contact information
3. make a simple database system using text files
4. design a backup utility that copies important files

## key concepts mastered

## example from class

here's a simple file reading example that demonstrates basic file operations:

```python
# file handling
file = open('something/idontknow.txt', 'r')
print(file.read())
```

**what this code demonstrates:**
- **open() function**: opens a file in read mode ('r')
- **file.read()**: reads the entire contents of the file
- **print() function**: displays the file contents
- **file path**: specifies the location of the file to read

**important note**: this example shows the basic syntax, but it's missing proper file closing and error handling. in production code, you should always use:

```python
# better approach with proper file handling
try:
    with open('something/idontknow.txt', 'r') as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("file not found")
except IOError:
    print("error reading file")
```

this improved version uses the `with` statement to automatically close the file and includes error handling for common file operation problems.

## key concepts mastered

• files provide permanent data storage beyond program execution
• use "with" statements for automatic file closing and error handling
• different modes (r, w, a) provide different file access capabilities
• read() loads entire files, readline() processes line by line
• proper error handling prevents crashes from file operation failures
• logging systems track application activity and help debug problems
• file handling is essential for data persistence in real applications
