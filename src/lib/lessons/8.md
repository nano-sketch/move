---
title: "regex & validation"
lesson: 8
quizzes:
  - question: "which module do you import for regular expressions?"
    options:
      - "regex"
      - "re"
      - "regexp"
      - "pattern"
    correct: 1
  - question: "what does the pattern \\d+ match?"
    options:
      - "one or more letters"
      - "one or more digits"
      - "one or more spaces"
      - "one or more symbols"
    correct: 1
  - question: "which function checks if a pattern matches the entire string?"
    options:
      - "re.search()"
      - "re.match()"
      - "re.fullmatch()"
      - "re.find()"
    correct: 2
---

# regex & validation

**real world analogy**: regular expressions are like a sophisticated search function in a word processor, but instead of finding exact words, they can find patterns. imagine searching for "any phone number" or "any email address" • regex makes this possible by describing what these patterns look like.

## understanding regular expressions

regular expressions (regex) are powerful pattern-matching tools that help you find, validate, and extract specific text patterns. they're like a secret language for describing what text should look like.

```python
import re

email = "user@example.com"
pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

if re.match(pattern, email):
    print("valid email format")
else:
    print("invalid email format")
```

this code checks if an email follows the correct format. the pattern describes what a valid email should look like: letters/numbers/symbols, followed by @, followed by a domain name with a dot and extension.

## basic regex patterns

regex uses special characters to describe patterns. these building blocks let you create sophisticated search criteria.

```python
import re

text = "my phone number is 555-123-4567 and my zip is 12345"

phone_pattern = r"\d{3}-\d{3}-\d{4}"
zip_pattern = r"\d{5}"

phone_match = re.search(phone_pattern, text)
zip_match = re.search(zip_pattern, text)

if phone_match:
    print(f"found phone: {phone_match.group()}")

if zip_match:
    print(f"found zip: {zip_match.group()}")
```

\d matches any digit, {3} means exactly 3 times, {5} means exactly 5 times. the hyphen (-) matches literally. this pattern finds phone numbers in xxx-xxx-xxxx format and 5-digit zip codes.

## password validation with regex

password validation is a perfect use case for regex. you can check for multiple requirements in a single pattern.

```python
import re

def validate_password(password):
    if len(password) < 8:
        return False, "password must be at least 8 characters"
    
    if not re.search(r"[a-z]", password):
        return False, "password must contain lowercase letters"
    
    if not re.search(r"[A-Z]", password):
        return False, "password must contain uppercase letters"
    
    if not re.search(r"\d", password):
        return False, "password must contain numbers"
    
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "password must contain special characters"
    
    return True, "password is strong"

passwords = ["weak", "StrongPass123!", "nodigits", "NOUPPERCASE123!"]

for pwd in passwords:
    is_valid, message = validate_password(pwd)
    print(f"'{pwd}': {message}")
```

this function checks each password requirement separately. [a-z] matches lowercase letters, [A-Z] matches uppercase, \d matches digits, and the character class matches special symbols.

## email validation system

email validation demonstrates how regex can handle complex real-world patterns with multiple components.

```python
import re

def validate_email(email):
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    
    if re.fullmatch(pattern, email):
        return True, "valid email address"
    else:
        return False, "invalid email format"

def extract_email_parts(email):
    pattern = r"^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+)\.([a-zA-Z]{2,})$"
    match = re.match(pattern, email)
    
    if match:
        username = match.group(1)
        domain = match.group(2)
        extension = match.group(3)
        return username, domain, extension
    else:
        return None, None, None

emails = [
    "user@example.com",
    "test.email+tag@domain.co.uk",
    "invalid.email",
    "user@domain"
]

for email in emails:
    is_valid, message = validate_email(email)
    print(f"{email}: {message}")
    
    if is_valid:
        user, domain, ext = extract_email_parts(email)
        print(f"  username: {user}, domain: {domain}, extension: {ext}")
```

the ^ and $ anchors ensure the pattern matches the entire string. parentheses create groups that can be extracted separately, letting you parse the email into its components.

## phone number validation and formatting

phone numbers come in many formats. regex can validate and standardize them.

```python
import re

def validate_and_format_phone(phone):
    digits_only = re.sub(r"[^\d]", "", phone)
    
    if len(digits_only) == 10:
        formatted = f"({digits_only[:3]}) {digits_only[3:6]}-{digits_only[6:]}"
        return True, formatted
    elif len(digits_only) == 11 and digits_only[0] == "1":
        formatted = f"1-({digits_only[1:4]}) {digits_only[4:7]}-{digits_only[7:]}"
        return True, formatted
    else:
        return False, "invalid phone number"

phone_numbers = [
    "555-123-4567",
    "(555) 123-4567",
    "5551234567",
    "1-555-123-4567",
    "555.123.4567",
    "123-45-67"
]

for phone in phone_numbers:
    is_valid, result = validate_and_format_phone(phone)
    print(f"{phone} -> {result}")
```

re.sub() replaces patterns with new text. [^\d] matches any non-digit character, so this removes everything except numbers. then the code reformats the clean digits into a standard format.

## data extraction from text

regex excels at finding and extracting structured data from unstructured text.

```python
import re

def extract_contact_info(text):
    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
    phone_pattern = r"\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}"
    url_pattern = r"https?://[^\s]+"
    
    emails = re.findall(email_pattern, text)
    phones = re.findall(phone_pattern, text)
    urls = re.findall(url_pattern, text)
    
    return {
        "emails": emails,
        "phones": phones,
        "urls": urls
    }

sample_text = """
contact john doe at john.doe@company.com or call (555) 123-4567.
you can also visit our website at https://www.company.com
for more information. backup contact: jane@company.com, 555.987.6543
"""

contact_info = extract_contact_info(sample_text)
print("extracted contact information:")
for info_type, items in contact_info.items():
    print(f"{info_type}: {items}")
```

re.findall() returns all matches in the text as a list. this function can process any text and automatically extract all email addresses, phone numbers, and urls.

## real-world applications

regex powers search engines, form validation, data cleaning, log analysis, text processing, and content filtering. it's essential for handling user input and processing text data in professional applications.

## practice challenges

1. create a credit card validator that handles different card formats
2. build a social security number validator and formatter
3. make a url parser that extracts protocol, domain, and path
4. design a log file analyzer that extracts timestamps and error messages

## key concepts mastered

• regular expressions match text patterns using special syntax
• import re module to use regex functions in python
• basic patterns: \d (digits), \w (word characters), \s (whitespace)
• quantifiers: + (one or more), * (zero or more), {n} (exactly n)
• character classes: [a to z] (lowercase), [A to Z] (uppercase), [0 to 9] (digits)
• anchors: ^ (start of string), $ (end of string)
• groups: parentheses capture parts of matches for extraction
• re.match(), re.search(), re.findall(), re.sub() handle different regex tasks
• regex is powerful for validation, extraction, and text processing
