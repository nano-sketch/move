---
title: "error handling"
lesson: 7
quizzes:
  - question: "which keyword starts error handling in python?"
    options:
      - "catch"
      - "try"
      - "handle"
      - "error"
    correct: 1
  - question: "what happens if you don't handle an error?"
    options:
      - "program continues normally"
      - "program crashes"
      - "error is ignored"
      - "python fixes it automatically"
    correct: 1
  - question: "which block runs when no error occurs?"
    options:
      - "except"
      - "finally"
      - "else"
      - "catch"
    correct: 2
---

# error handling

**real world analogy**: error handling is like having a first aid kit when hiking. you hope you won't need it, but when something goes wrong (like a cut or sprain), you're prepared to handle the situation gracefully instead of letting it ruin your entire trip.

## understanding errors

errors are inevitable in programming - users enter invalid data, files don't exist, network connections fail. instead of letting these errors crash your program, you can catch them and respond appropriately.

**what happens without error handling:**
```python
# try running this - it will crash!
age = int("abc")  # ValueError: invalid literal for int()
print("this line never runs")
```

**with error handling:**
```python
try:
    # risky code that might fail
    age = int(input("enter your age: "))
    print(f"you are {age} years old")
except ValueError:
    # runs if conversion fails
    print("please enter a valid number")
```

**test this yourself:** run the code and try entering "abc" instead of a number. without the try-except, your program would crash with a red error message. with it, you get a friendly response.

## the try-except structure

try-except blocks work like safety nets. you put risky code in the try block, and if something goes wrong, the except block catches the error and handles it gracefully.

**examples of errors you'll see:**
```python
# ValueError example - try this!
int("hello")  # ValueError: invalid literal for int() with base 10: 'hello'

# ZeroDivisionError example - try this!
10 / 0  # ZeroDivisionError: division by zero
```

**handling multiple error types:**
```python
try:
    # get user input
    number = int(input("enter a number: "))
    # attempt division
    result = 100 / number
    print(f"100 divided by {number} is {result}")
except ValueError:
    # handles bad input like "abc"
    print("that's not a valid number!")
except ZeroDivisionError:
    # handles division by zero
    print("cannot divide by zero!")
```

**test this:** try entering "abc", then try entering "0", then try entering "5". see how each input triggers different responses.

## common error types

understanding different error types helps you handle specific problems appropriately.

**try these examples to see the errors:**
```python
# ValueError - bad data conversion
int("hello")  # ValueError: invalid literal for int()

# IndexError - list position doesn't exist  
my_list = [1, 2, 3]
print(my_list[10])  # IndexError: list index out of range

# KeyError - dictionary key doesn't exist
my_dict = {"name": "alice"}
print(my_dict["age"])  # KeyError: 'age'

# FileNotFoundError - file doesn't exist
open("missing.txt")  # FileNotFoundError: No such file or directory
```

**handling specific errors:**
```python
try:
    # try different risky operations
    number = int(input("enter number: "))
    my_list = [1, 2, 3]
    print(my_list[number])
except ValueError:
    print("please enter a valid number")
except IndexError:
    print("number too big for list")
```

**experiment:** run this code and try entering "abc", then "10", then "1". see how different inputs cause different errors.

## the else and finally blocks

else runs when no errors occur, finally runs no matter what happens. they provide additional control over error handling flow.

```python
try:
    # try to do math
    number = int(input("enter a number: "))
    result = 10 / number
except ValueError:
    # runs if input is bad
    print("invalid number")
except ZeroDivisionError:
    # runs if number is zero
    print("cannot divide by zero")
else:
    # runs only if no errors happened
    print(f"result is {result}")
finally:
    # always runs, no matter what
    print("calculation attempt finished")
```

**test this:** try entering "5" (works fine), then "0" (division error), then "abc" (value error). notice how the finally block always runs, but else only runs when there are no errors.

## input validation with error handling

error handling shines when validating user input, creating robust programs that handle any input gracefully.

```python
# simple input validation loop
while True:
    try:
        # ask for user input
        age = int(input("enter your age: "))
        # check if age makes sense
        if age < 0 or age > 120:
            print("age must be between 0 and 120")
            continue  # ask again
        # if we get here, input is valid
        break
    except ValueError:
        # input wasn't a number
        print("please enter a valid number")

print(f"you are {age} years old")
```

**what this does:**
- keeps asking until you enter a valid number
- checks if the number is reasonable (0-120)
- handles bad input like "abc" gracefully
- only stops when it gets good input

**test this:** try entering "abc", then "-5", then "150", then "25". see how it handles each case.

## file handling with error protection

file operations are prone to errors - files might not exist, be locked, or have permission issues. proper error handling makes file operations reliable.

**what happens without error handling:**
```python
# this will crash if file doesn't exist!
file = open("missing.txt", "r")  # FileNotFoundError: No such file or directory
```

**with error handling:**
```python
try:
    # try to open and read file
    with open("data.txt", "r") as file:
        content = file.read()
        print(f"file contents: {content}")
except FileNotFoundError:
    # file doesn't exist
    print("file not found - creating new one")
    with open("data.txt", "w") as file:
        file.write("hello world!")
except PermissionError:
    # no permission to access file
    print("permission denied")
```

**test this:** run the code when "data.txt" doesn't exist, then run it again when the file exists. see how it handles both situations gracefully.

## real-world applications

error handling is crucial in web applications (handling network failures), data processing (managing corrupt data), user interfaces (validating input), and any program that interacts with external systems or users.

## practice challenges

1. create a calculator that handles all possible input errors
2. build a file manager that gracefully handles missing files and permissions
3. make a data processor that continues working despite corrupt entries
4. design a user registration system with comprehensive input validation

## key concepts mastered

• try except blocks catch and handle errors gracefully
• different exception types represent specific error conditions
• else blocks run only when no errors occur
• finally blocks always run, perfect for cleanup tasks
• proper error handling prevents program crashes
• input validation with error handling creates robust user interfaces
• file operations should always include error handling
• good error messages help users understand and fix problems reusable code. Master them and your programming will improve dramatically.
