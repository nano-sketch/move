---
title: "python dictionaries"
lesson: 10
quizzes:
  - question: "how do you create an empty dictionary?"
    options:
      - "dict = []"
      - "dict = ()"
      - "dict = {}"
      - "dict = new Dictionary()"
    correct: 2
  - question: "how do you access a value with key 'name'?"
    options:
      - "dict.name"
      - "dict['name']"
      - "dict('name')"
      - "dict->name"
    correct: 1
  - question: "which method returns all keys in a dictionary?"
    options:
      - "dict.keys()"
      - "dict.getKeys()"
      - "dict.allKeys()"
      - "dict.keyList()"
    correct: 0
---

# python dictionaries

**real world analogy**: dictionaries are like a phone book or contact list. instead of looking up information by position (like lists), you look up values by meaningful names (keys). just as you find someone's phone number by their name, dictionaries let you find data using descriptive labels.

## understanding dictionaries

dictionaries store information in key-value pairs, making data retrieval fast and intuitive. they're perfect when you need to associate related pieces of information.

```python
student = {
    "name": "alice johnson",
    "age": 20,
    "major": "computer science",
    "gpa": 3.8,
    "courses": ["python", "algorithms", "databases"]
}

print(f"student: {student['name']}")
print(f"age: {student['age']}")
print(f"gpa: {student['gpa']}")
print(f"courses: {student['courses']}")
```

each key (like "name" or "age") maps to a specific value. keys must be unique and immutable (strings, numbers, tuples), while values can be any data type including lists, other dictionaries, or objects.

## creating and modifying dictionaries

dictionaries are mutable - you can add, update, and remove key-value pairs after creation.

```python
inventory = {}

inventory["apples"] = 50
inventory["bananas"] = 30
inventory["oranges"] = 25

print("initial inventory:", inventory)

inventory["apples"] = 45
inventory["grapes"] = 40

print("updated inventory:", inventory)

del inventory["bananas"]
removed_item = inventory.pop("oranges", 0)

print(f"removed {removed_item} oranges")
print("final inventory:", inventory)
```

square bracket notation adds new keys or updates existing ones. del removes key-value pairs permanently, while pop() removes and returns the value (with an optional default if the key doesn't exist).

## safe dictionary access

accessing non-existent keys causes errors. the get() method provides safe access with optional default values.

```python
user_profile = {
    "username": "john_doe",
    "email": "john@example.com",
    "age": 28
}

print("unsafe access:")
try:
    phone = user_profile["phone"]
except KeyError:
    print("phone number not found")

print("\nsafe access with get():")
phone = user_profile.get("phone", "not provided")
age = user_profile.get("age", "unknown")
location = user_profile.get("location", "not specified")

print(f"phone: {phone}")
print(f"age: {age}")
print(f"location: {location}")
```

get() returns the value if the key exists, or the default value (None if not specified) if it doesn't. this prevents crashes and makes your code more robust.

## iterating through dictionaries

dictionaries provide multiple ways to loop through their contents, giving you access to keys, values, or both.

```python
grades = {
    "math": 92,
    "science": 88,
    "english": 95,
    "history": 87,
    "art": 91
}

print("method 1: iterate through keys")
for subject in grades:
    print(f"{subject}: {grades[subject]}")

print("\nmethod 2: iterate through key-value pairs")
for subject, grade in grades.items():
    print(f"{subject}: {grade}")

print("\nmethod 3: iterate through values only")
total = sum(grades.values())
average = total / len(grades)
print(f"average grade: {average:.1f}")

print("\nmethod 4: iterate through keys explicitly")
for subject in grades.keys():
    if grades[subject] >= 90:
        print(f"excellent grade in {subject}: {grades[subject]}")
```

items() returns key-value pairs, keys() returns just keys, and values() returns just values. choose the method that best fits your needs.

## nested dictionaries for complex data

dictionaries can contain other dictionaries, creating hierarchical data structures perfect for representing complex information.

```python
company = {
    "name": "tech innovations inc",
    "founded": 2020,
    "employees": {
        "alice": {
            "position": "software engineer",
            "salary": 75000,
            "department": "development",
            "skills": ["python", "javascript", "sql"]
        },
        "bob": {
            "position": "data analyst",
            "salary": 65000,
            "department": "analytics",
            "skills": ["python", "r", "statistics"]
        },
        "charlie": {
            "position": "project manager",
            "salary": 80000,
            "department": "management",
            "skills": ["leadership", "planning", "communication"]
        }
    }
}

print(f"company: {company['name']}")
print(f"founded: {company['founded']}")
print("\nemployee information:")

for name, info in company["employees"].items():
    print(f"{name}:")
    print(f"  position: {info['position']}")
    print(f"  salary: ${info['salary']:,}")
    print(f"  department: {info['department']}")
    print(f"  skills: {', '.join(info['skills'])}")
    print()
```

nested dictionaries organize related data hierarchically. access nested values by chaining square brackets: company["employees"]["alice"]["salary"].

## dictionary methods and operations

dictionaries come with powerful built-in methods for common operations like merging, copying, and bulk updates.

```python
original_config = {
    "debug": True,
    "database_url": "localhost:5432",
    "max_connections": 100
}

new_settings = {
    "debug": False,
    "timeout": 30,
    "cache_enabled": True
}

print("original config:", original_config)

config_copy = original_config.copy()
config_copy.update(new_settings)

print("updated config:", config_copy)
print("original unchanged:", original_config)

all_keys = list(config_copy.keys())
all_values = list(config_copy.values())

print(f"all keys: {all_keys}")
print(f"all values: {all_values}")

if "timeout" in config_copy:
    print(f"timeout setting: {config_copy['timeout']}")

config_copy.clear()
print("cleared config:", config_copy)
```

copy() creates a shallow copy, update() merges another dictionary, clear() removes all items, and the in operator checks for key existence.

## practical applications

dictionaries excel at counting, grouping, caching, and representing structured data like json apis, configuration files, and database records.

```python
def analyze_text(text):
    words = text.lower().split()
    
    word_count = {}
    for word in words:
        clean_word = word.strip(".,!?;:")
        word_count[clean_word] = word_count.get(clean_word, 0) + 1
    
    letter_count = {}
    for char in text.lower():
        if char.isalpha():
            letter_count[char] = letter_count.get(char, 0) + 1
    
    return {
        "total_words": len(words),
        "unique_words": len(word_count),
        "word_frequency": word_count,
        "letter_frequency": letter_count,
        "most_common_word": max(word_count, key=word_count.get),
        "most_common_letter": max(letter_count, key=letter_count.get)
    }

sample_text = "python is amazing and python makes programming fun"
analysis = analyze_text(sample_text)

print("text analysis results:")
print(f"total words: {analysis['total_words']}")
print(f"unique words: {analysis['unique_words']}")
print(f"most common word: '{analysis['most_common_word']}'")
print(f"most common letter: '{analysis['most_common_letter']}'")

print("\nword frequencies:")
for word, count in sorted(analysis['word_frequency'].items()):
    print(f"  {word}: {count}")
```

this example demonstrates how dictionaries naturally solve counting and analysis problems. the get() method with a default value makes counting elegant and efficient.

## real-world applications

dictionaries power json apis, database orm systems, caching mechanisms, configuration management, user session data, and any application requiring fast key-based lookups.

## practice challenges

1. create a student grade book that tracks multiple subjects per student
2. build a simple inventory management system with product details
3. make a word game that tracks letter frequencies and scores
4. design a contact manager with search and categorization features

## key concepts mastered

• dictionaries store key value pairs for fast, meaningful data access
• keys must be unique and immutable, values can be any data type
• use square brackets to add, update, or access values
• get() method provides safe access with optional defaults
• items(), keys(), values() methods enable flexible iteration
• nested dictionaries create hierarchical data structures
• dictionaries are mutable and provide methods for copying, updating, clearing
• perfect for counting, grouping, caching, and representing structured data
• essential for modern programming patterns and data processing
